(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{112:function(e,t,a){"use strict";a.r(t);var o=a(0),r=Object(o.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"definition-ternary-huffman-codes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#definition-ternary-huffman-codes","aria-hidden":"true"}},[e._v("#")]),e._v(" Definition: Ternary Huffman Codes")]),a("p",[e._v("We saw how to construct "),a("i",[e._v("binary")]),e._v(" Huffman codes. We can also generate Huffman codes for larger alphabets, resulting in ternary, quaternary, or, more generally, "),a("span",{staticStyle:{color:"#bc0031"}},[a("strong",[e._v("\\(d\\)-ary Huffman codes")])]),e._v(".")]),a("div",{staticClass:"content-box pad-box-mini border border-trbl border-round"},[a("h4",{staticStyle:{color:"#2d3b45"}},[a("strong",[e._v("Example: Ternary Huffman code")])]),e._v("\nWe build a Huffman code with the alphabet \\(\\{0,1,2\\}\\) for the same distribution as in the previous example.\n"),a("p",[a("img",{attrs:{src:"https://canvas.uva.nl/courses/2205/files/180622/download?verifier=vJPpF4jcAM2G7f1AGBvjJTOW861BpxxSTL7RzLen",alt:"huffman3-1.svg","data-api-endpoint":"https://canvas.uva.nl/api/v1/courses/2205/files/180622","data-api-returntype":"File"}})]),a("p",[e._v("Now, use the above procedure to construct a ternary code for the source \\(P_X\\) with \\(\\mathcal{X} = \\{a,b,c,d,e,f\\}\\) and \\(P_X(a) = P_X(b) = 0.25\\), \\(P_X(c) = 0.2\\), \\(P_X(d) = P_X(e) = P_X(f) = 0.1\\). Can you find another code with a smaller average codeword length?")])]),a("p",[e._v("We have to be careful, because with an alphabet size of greater than 2, the above procedure does not always give an optimal code! In fact, a \\(d\\)-ary code is only optimal if \\(|\\mathcal{X}|\\) is of the form \\(k(d-1)+1\\) for some \\(k \\in \\mathbb{N}\\). This ensures that at every step, we can combine exactly \\(d\\) symbols to use the alphabet at full capacity. The ternary code in the example above is optimal because \\(|\\mathcal{X}| = 5 = 2(3-1) + 1\\), but the code you constructed in the exercise is not. To remedy this, one can add one or more `dummy' symbols to the source (each with probability zero) until an appropriate size of \\(\\mathcal{X}\\) of the form \\(|\\mathcal{X}| = k(d-1)+1\\) for some \\(k \\in \\mathbb{N}\\) is reached. The codewords for those dummy symbols are discarded at the end. It turns out that Huffman codes indeed have optimal code length (see "),a("a",{attrs:{href:"http://onlinelibrary.wiley.com/book/10.1002/0471200611",target:"_blank"}},[e._v("Cover/Thomas")]),e._v(", Section 5.8)")]),a("h4",[e._v("Ternary code applet")]),a("p",[a("iframe",{attrs:{src:"https://esc.fnwi.uva.nl/blend/information-theory/interactive-graphs/ternary-codes.htm",width:"1000",height:"350"}})])])}],!1,null,null,null);r.options.__file="README.md";t.default=r.exports}}]);